<html>
<head>
<script src="libs/request.min.js"></script>
<script src="libs/stanzaio.bundle.js"></script>
<script src="libs/sdp-jingle-json.bundle.js"></script>
<script src="xmppvideoroom.json" ></script>
</head>
<body> 
	XMPP Url:<input id="xmppServer" type="text" size="50" /> 
	Room id:<input id="xmppRoom" type="text" />
	User id:<input id="xmppUser" type="text"  />
	<input type="button" value="connect" onclick="connect()" />
	<input type="button" value="disconnect" onclick="disconnect()" />
</body>
<script>
	// set default value
	document.querySelector('#xmppServer').value  = xmppRoomConfig.url;
	document.querySelector('#xmppRoom').value = xmppRoomConfig.roomId;
	document.querySelector('#xmppUser').value = xmppRoomConfig.user;
	
	
	var peerid = Math.random();
	var webrtcStream = "screen://"

	function write(text, value) {
		var textNode = document.createElement("li");
		textNode.textContent = text;
		if (value instanceof Array) {
			var arrayNode = document.createElement("ul");
			value.forEach((itemText) => {
				var item = document.createElement("li");
				item.textContent = JSON.stringify(itemText);		
				arrayNode.appendChild(item);				
			})
			textNode.appendChild(arrayNode);
		}
		document.body.appendChild(textNode);
	}
	
	function onError (error) {
		write("############onError:" + error)
	}
	
	var client = null;
	var sid = null;
	var sessionid = null;

	function onCall(iq, data) {
	
		// send ICE candidate to webrtc-streamer
		iq.jingle.contents.forEach(function (content) {
			var candidates = content.transport.candidates || [];
			candidates.forEach(function (candidate) {
				var sdp = SJJ.toCandidateSDP(candidate);
				sdp = sdp.replace("a=candidate","candidate");
				write("============sdp:" + sdp);
				var candidate = { candidate:sdp, sdpMid:content.name, sdpMLineIndex:0 }
				
				var method = "/api/addIceCandidate?peerid="+ peerid;
				request("POST" , method, { body: JSON.stringify(candidate) }).done( function (response) { 
						if (response.statusCode === 200) {
							write("method:"+method+ " answer:" +response.body);
						}
						else {
							onError(response.statusCode);
						}
					}
				);				
			});
		});	
				
		// send WebRTC answer to XMPP server
		write("answer============sdp:" + data.sdp);		
		var json = SJJ.toOutgoingJSONAnswer(data.sdp);		
		client.sendIq({ type: "set", 
				from: iq.to,
				to: iq.from,
				jingle:{
					action:"session-accept",
					sid:iq.jingle.sid,
					responder:iq.to,
					contents:json.contents
				}
		}).then(function(result) {
			sid = iq.jingle.sid;
			write("============session-accept ok sid:" +  sid);
				
			var method = "/api/getIceCandidate?peerid="+ peerid;
			request("GET" , method).done( function (response) { 
					if (response.statusCode === 200) {
						onReceiveCandidate(iq,JSON.parse(response.body));
					}
					else {
						onError(response.statusCode);
					}
				}
			);					
		}).catch(function(result) {
			write("############session-accept error result:" +  JSON.stringify(result));
		});
	}

	function onCreateOffer(iq, data) {
	
				
		// send WebRTC answer to XMPP server
		var json = SJJ.toOutgoingJSONOffer(data.sdp);		
		client.sendIq({ type: "set", 
				from: iq.to,
				to: iq.from,
				jingle:{
					action:"session-accept",
					sid:iq.jingle.sid,
					initiator:iq.from,
					contents:json.contents
				}
		}).then(function(result) {
			sid = iq.jingle.sid;
			write("============session-accept ok sid:" +  sid);

			var sdp = SJJ.toOutgoingSDPAnswer(iq.jingle);
			write("answer============sdp:" + sdp);
			var answer = { type:"answer", sdp }
			
			var method = "/api/setAnswer?peerid="+ peerid;
			request("POST" , method, { body: JSON.stringify(answer) }).done( function (response) { 
					if (response.statusCode === 200) {
						write("method:"+method+ " answer:" +response.body);
					}
					else {
						onError(response.statusCode);
					}
				}
			);				
			
			// send ICE candidate to webrtc-streamer
			iq.jingle.contents.forEach(function (content) {
				var candidates = content.transport.candidates || [];
				candidates.forEach(function (candidate) {
					var sdp = SJJ.toCandidateSDP(candidate);
					sdp = sdp.replace("a=candidate","candidate");
					write("============sdp:" + sdp);
					var candidate = { candidate:sdp, sdpMid:content.name, sdpMLineIndex:0 }
					
					var method = "/api/addIceCandidate?peerid="+ peerid;
					request("POST" , method, { body: JSON.stringify(candidate) }).done( function (response) { 
							if (response.statusCode === 200) {
								write("method:"+method+ " answer:" +response.body);
							}
							else {
								onError(response.statusCode);
							}
						}
					);				
				});
			});	

			var method = "/api/getIceCandidate?peerid="+ peerid;
			request("GET" , method).done( function (response) { 
					if (response.statusCode === 200) {
						onReceiveCandidate(iq,JSON.parse(response.body));
					}
					else {
						onError(response.statusCode);
					}
				}
			);					
		}).catch(function(result) {
			write("############session-accept error result:" +  JSON.stringify(result));
		});
	}


	function onReceiveCandidate(iq, candidateList) {
		write("============candidateList:" +  JSON.stringify(candidateList));
		
		var candidates = []
		candidateList.forEach(function (candidate) {
			var json = SJJ.toCandidateJSON(candidate.candidate);
			write("============candidate:" +  JSON.stringify(json));
			candidates.push(json);
		});
		
		// send webrtc-streamer candidate to XMPP server
		client.sendIq({ type: "set", 
				from: iq.to,
				to: iq.from,
				jingle:{
					action:"transport-info",
					sid:iq.jingle.sid,
					contents:{
						transport:{candidates}
					}
		}}).then(function(result) {
			write("============transport-info ok result:" +  JSON.stringify(result));		
		}).catch(function(result) {
			write("############transport-info error result:" +  JSON.stringify(result));
		});
;
	}
	
	function connect() {
		var serverName = document.querySelector('#xmppServer').value;
		var userName = document.querySelector('#xmppUser').value;	
		var roomName = document.querySelector('#xmppRoom').value;
		var mucUrl = "conference." + serverName;
		var roomUrl = roomName + "@" + mucUrl;
	
		client = XMPP.createClient({
		  jid: roomName + "@" + serverName,
		  boshURL: location.protocol+ "//" + serverName + "/http-bind",
		  transports: ['bosh']
		});
		
		client.on('session:started', (jid) => {		
			sessionid = jid;
			write("session:started: jid:" + jid)			

			var caps = client.updateCaps();
			write("caps features:", caps.discoInfo.features)		
			
			client.getDiscoInfo(serverName,'', (err, data) => { write(serverName +" info:", data.discoInfo.features) });
			client.getDiscoInfo(mucUrl,'', (err, data) => { write(mucUrl +" info:", data.discoInfo.features) });
			client.getDiscoInfo(roomUrl,'', (err, data) => { write(roomUrl +" info:", data.discoInfo.features) });
			
			client.getDiscoItems(serverName,'', (err, data) => { write(serverName +" item:", data.discoItems.items) });
			client.getDiscoItems(mucUrl,'', (err, data) => { write(mucUrl +" item:", data.discoItems.items) });
			client.getDiscoItems(roomUrl,'', (err, data) => { write(roomUrl + " item:", data.discoItems.items) });
			
			client.joinRoom(roomUrl, userName, {type:"available",nick:userName});				
		} );
				
//		client.on('message', (data) => {write("message:" + JSON.stringify(data))} )		
//		client.on('stanza', (data) => {write("stanza:" + JSON.stringify(data))} )
				
		client.on('muc:available', function (pres) { write("muc:available from:" + pres.from); });
		client.on('muc:leave', function (pres) { write("muc:leave from:" + pres.from); });
		client.on('muc:join', function (pres) {
			write("muc:join from:" + pres.from);		

			if (pres.from.resource === userName) {
				write("user joined");
//				client.sendMessage({ to: roomUrl, type:"groupchat", body:"Hello!" });	
			}
								
		});

		client.on('presence', function (pres) {
		    write("presence from:" + pres.from + " type:" + pres.type)
		});
		
		client.on('iq', function(iq) {	
			write("iq:from:" + iq.from + " to:"+ iq.to + " " + JSON.stringify(iq));
			
			if ( iq.jingle && (iq.jingle.action === "session-initiate") && iq.jingle.contents) {
				if (iq.jingle.initiator.indexOf("focus@") === 0)  {	
				
					var sdp = SJJ.toOutgoingSDPOffer(iq.jingle);
					write("offer============sdp:" + sdp);							
					
					var method = "/api/call?peerid="+ peerid+"&url="+encodeURIComponent(webrtcStream)+"&audiourl=none"+"&options="+encodeURIComponent("rtptransport=tcp");
					request("POST" , method, {body:JSON.stringify({type:"offer",sdp})}).done( function (response) { 
							if (response.statusCode === 200) {
								onCall(iq,JSON.parse(response.body));
							}
							else {
								onError(response.statusCode);
							}
						}
					);				
				} else {
				/*
					var method = "/api/createOffer?peerid="+ peerid+"&url="+encodeURIComponent(webrtcStream)+"&audiourl=none"+"&options="+encodeURIComponent("rtptransport=tcp");
					request("GET" , method).done( function (response) { 
							if (response.statusCode === 200) {
								onCreateOffer(iq,JSON.parse(response.body));
							}
							else {
								onError(response.statusCode);
							}
						}
					);
*/					
				}
			}						
		});

		client.disco.addIdentity({ category: 'client', type: 'phone' });
//		client.disco.addFeature("urn:ietf:rfc:5761") // rtcp-mux	

		client.connect();			
				
	}
	
	function disconnect() {
		var serverName = document.querySelector('#xmppServer').value;
		var userName = document.querySelector('#xmppUser').value;	
		var roomName = document.querySelector('#xmppRoom').value;
		var muc = "conference." + serverName;
		var roomUrl = roomName + "@" + muc;

		if (client) {
			if (sid) {
				client.sendIq({ type: "set", 
					from: roomUrl +"/" + userName,
					to: sessionid,
					jingle:{
						action:"session-terminate",
						sid:sid
					}
				})	
				sid = null;
			}				
		
			client.leaveRoom(roomUrl, userName);
			client = null;
		
			var method = "/api/hangup?peerid="+ peerid;
			request("GET" , method).done( function (response) { 
					if (response.statusCode === 200) {
						write("method:"+method+ " answer:" +response.body);
					}
					else {
						onError(response.statusCode);
					}
				}
			);		
		}
	}
	
	window.onbeforeunload = function() { 
		disconnect();
	};		
</script>
</html>
